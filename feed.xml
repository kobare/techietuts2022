<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-04-29T18:40:18+03:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Techietuts</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">An Overview of RESTful API Design Principles in Rails</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/an-overview-of-restful-api-design-principles-in-rails" rel="alternate" type="text/html" title="An Overview of RESTful API Design Principles in Rails" /><published>2023-04-29T13:00:00+03:00</published><updated>2023-04-29T13:00:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/an-overview-of-restful-api-design-principles-in-rails</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/an-overview-of-restful-api-design-principles-in-rails">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;With the rise of web applications, the need for APIs has increased in the software 
development industry. RESTful APIs are widely used because of their simplicity, 
scalability, and compatibility with HTTP. RESTful APIs can be implemented in any 
programming language or framework, including Ruby on Rails.&lt;/p&gt;

&lt;p&gt;Rails is a popular web application framework that provides out-of-the-box support 
for RESTful APIs. In this article, we will discuss the principles of RESTful API 
design in Rails and provide an overview of the tools and techniques used in their 
implementation.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;restful-api-principles&quot;&gt;RESTful API Principles&lt;/h3&gt;

&lt;p&gt;REST stands for Representational State Transfer, which is a set of principles used 
to design web services. RESTful APIs follow the following principles:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;1--resource-oriented-architecture&quot;&gt;1 . Resource-Oriented Architecture&lt;/h4&gt;

&lt;p&gt;RESTful APIs are based on resources that represent a collection of related objects. 
Each resource is identified by a unique URI, and the interactions with the resource 
are defined by HTTP methods like GET, POST, PUT, and DELETE.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2--client-server-model&quot;&gt;2 . Client-Server Model&lt;/h4&gt;

&lt;p&gt;RESTful APIs follow the client-server model, where the client initiates the request, 
and the server responds with the data. The server-side application exposes a set 
of endpoints that can be accessed by the client.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;3--stateless&quot;&gt;3 . Stateless&lt;/h4&gt;
&lt;p&gt;RESTful APIs are stateless, meaning that each request is treated independently of 
the previous request. The server does not store any client-specific data between 
requests, and each request must contain all the necessary information to fulfill 
the request.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;4--cacheable&quot;&gt;4 . Cacheable&lt;/h4&gt;

&lt;p&gt;RESTful APIs are designed to be cacheable, meaning that the response to a request 
can be cached by the client or a proxy server. This reduces the number of requests 
sent to the server and improves the performance of the application.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;5--uniform-interface&quot;&gt;5 . Uniform Interface&lt;/h4&gt;

&lt;p&gt;RESTful APIs have a uniform interface, which means that the interaction between 
the client and server is standardized. The interface includes the use of HTTP 
methods, resource URIs, media types, and response codes.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;implementing-restful-apis-in-rails&quot;&gt;Implementing RESTful APIs in Rails&lt;/h3&gt;

&lt;p&gt;Rails provides a framework for building RESTful APIs that follow the above 
principles. Rails implements RESTful routing, which means that it maps HTTP 
requests to controller actions based on the HTTP method and the resource URI.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;1--defining-resources&quot;&gt;1 . Defining Resources&lt;/h4&gt;

&lt;p&gt;In Rails, resources are defined in the routes.rb file. The resources method 
generates a set of RESTful routes for a given controller. For example, the 
following code defines a resource for a blog post:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:posts&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will generate the following RESTful routes:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/posts
GET /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/posts
PUT /&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/posts/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;2--using-http-methods&quot;&gt;2 . Using HTTP Methods&lt;/h4&gt;

&lt;p&gt;HTTP methods are used to interact with the resources in Rails. The following 
table shows the HTTP methods and their corresponding controller actions:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;style&gt;
  th {
    background-color: lightgrey;
  }
  table {
    border-collapse: collapse;
    border: 1px solid black;
    margin: 0 auto;
  }
  td, th {
    padding: 8px;
    border: 1px solid black;
  }
&lt;/style&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;HTTP Method&lt;/th&gt;
      &lt;th&gt;Controller Action&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;GET&lt;/td&gt;
      &lt;td&gt;index, show&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POST&lt;/td&gt;
      &lt;td&gt;create&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PUT&lt;/td&gt;
      &lt;td&gt;update&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DELETE&lt;/td&gt;
      &lt;td&gt;destroy&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
For example, the following code defines a controller action for retrieving all 
blog posts:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PostsController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ApplicationController&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@posts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;json: &lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@posts&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will respond to a GET request to /posts and return a JSON representation of all blog posts.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;3--handling-errors&quot;&gt;3 . Handling Errors&lt;/h4&gt;

&lt;p&gt;Rails provides a set of HTTP response codes that should be used to indicate the 
status of the request. The following table shows the HTTP response codes and 
their meaning:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;HTTP Response Code&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;200&lt;/td&gt;
      &lt;td&gt;OK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;201&lt;/td&gt;
      &lt;td&gt;Created&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;No Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;400&lt;/td&gt;
      &lt;td&gt;Bad Request&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;401&lt;/td&gt;
      &lt;td&gt;Unauthorized&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;403&lt;/td&gt;
      &lt;td&gt;Forbidden&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;404&lt;/td&gt;
      &lt;td&gt;Not Found&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;500&lt;/td&gt;
      &lt;td&gt;Internal Server Error&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
For example, the following code handles a not found error in Rails:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ActionController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;API&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rescue_from&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;ActiveRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RecordNotFound&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;json: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;error: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Record not found&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;status: :not_found&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will return a JSON response with an error message and a 404 status code.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ApplicationController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ActionController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;API&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rescue_from&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;ActiveRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RecordNotFound&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;json: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;error: &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Record not found&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;status: :not_found&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;4--versioning&quot;&gt;4 . Versioning&lt;/h4&gt;
&lt;p&gt;RESTful APIs often need to evolve over time, and versioning is used to manage 
these changes. Rails provides a mechanism for versioning APIs by specifying the 
version in the URI. For example, the following code defines a versioned resource:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:api&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:v1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resources&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:posts&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will generate the following URIs for the posts resource:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/api/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/api/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;POST&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/api/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;PUT&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/api/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/api/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;posts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4 id=&quot;5--authentication-and-authorization&quot;&gt;5 . Authentication and Authorization&lt;/h4&gt;
&lt;p&gt;RESTful APIs often require authentication and authorization to restrict access 
to resources. Rails provides several authentication and authorization gems, 
such as Devise and CanCanCan. These gems can be used to handle authentication 
and authorization in Rails.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;RESTful APIs are an essential part of modern web applications, and they are 
widely used by developers to build scalable and maintainable systems. Rails 
provides an excellent framework for building RESTful APIs, and it has become a 
popular choice for developers due to its simplicity and flexibility.&lt;/p&gt;

&lt;p&gt;When designing RESTful APIs in Rails, it is important to follow the principles 
of REST and use the tools and techniques provided by the framework. This includes 
defining resources, using HTTP methods, handling errors, versioning, and 
implementing authentication and authorization.&lt;/p&gt;

&lt;p&gt;By following these principles and using the tools provided by Rails, developers 
can build high-quality and scalable RESTful APIs that are easy to maintain and 
extend. However, it is important to keep in mind that designing RESTful APIs is 
an ongoing process, and it requires constant evaluation and iteration to ensure 
that it meets the changing needs of the application and its users.&lt;/p&gt;

&lt;p&gt;In conclusion, RESTful API design principles in Rails are an essential part of 
building modern web applications. By following these principles and using the 
tools provided by Rails, developers can build scalable and maintainable systems 
that provide a seamless experience for their users.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">How to use ActiveJob for background processing in Rails</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/how-to-use-activejob-for-background-processing-in-rails" rel="alternate" type="text/html" title="How to use ActiveJob for background processing in Rails" /><published>2023-04-22T13:30:00+03:00</published><updated>2023-04-22T13:30:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/how-to-use-activejob-for-background-processing-in-rails</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/how-to-use-activejob-for-background-processing-in-rails">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Background processing is an essential component of modern web applications. 
With the growing demand for high-performance applications, background processing 
is becoming increasingly important to handle long-running or resource-intensive 
tasks, such as sending emails, processing files, or generating reports. In the 
Ruby on Rails framework, ActiveJob is a convenient and straightforward way to 
perform background processing. ActiveJob provides a unified interface to work 
with different queuing backends, such as Delayed Job, Resque, or Sidekiq.&lt;/p&gt;

&lt;p&gt;In this section, we will explore how to use ActiveJob for background processing in Rails.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;what-is-activejob&quot;&gt;What is ActiveJob?&lt;/h3&gt;

&lt;p&gt;ActiveJob is a high-level interface for declaring, enqueuing, and executing 
background jobs in Rails applications. It is part of the Rails framework and 
abstracts away the differences between different queuing backends, allowing 
developers to switch between them with minimal effort.&lt;/p&gt;

&lt;p&gt;ActiveJob defines a simple API that developers can use to define jobs, specify 
parameters, and enqueue them for execution. Once a job is enqueued, ActiveJob 
takes care of dispatching it to the selected queuing backend, and then executing 
it asynchronously. ActiveJob also provides mechanisms for handling retries, 
failures, and monitoring the status of jobs.&lt;/p&gt;

&lt;p&gt;ActiveJob supports a wide range of queuing backends, including in-process queuing, 
database-backed queuing, and external queuing systems such as RabbitMQ, Amazon SQS, 
or Google Cloud Pub/Sub. This flexibility makes ActiveJob an excellent choice for 
any Rails application that needs to perform background processing.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;a-creating-an-activejob&quot;&gt;a). Creating an ActiveJob&lt;/h3&gt;

&lt;p&gt;To create a new ActiveJob, we can use the &lt;span class=&quot;badge&quot;&gt;rails generate job
&lt;/span&gt; command. This will 
generate a new job file in the &lt;span class=&quot;badge&quot;&gt;app/jobs&lt;/span&gt; directory of 
our Rails application. For example, to create a job called &lt;span class=&quot;badge&quot;&gt;
NotificationJob&lt;/span&gt;, we can run:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails generate job Notification&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will create a file called &lt;span class=&quot;badge&quot;&gt;notification_job.rb&lt;/span&gt; in 
the &lt;span class=&quot;badge&quot;&gt;app/jobs&lt;/span&gt; directory, with the following contents:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NotificationJob&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ApplicationJob&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;queue_as&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:default&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Do something later&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This file defines a new job class called &lt;span class=&quot;badge&quot;&gt;NotificationJob&lt;/span&gt;, 
which inherits from &lt;span class=&quot;badge&quot;&gt;ApplicationJob&lt;/span&gt;, the base class for 
all ActiveJobs in the Rails application. The queue_as method specifies the queue 
in which the job will be enqueued. In this case, we use the &lt;span class=&quot;badge&quot;&gt;
:default queue&lt;/span&gt;, which is the default queue for the selected queuing backend.&lt;/p&gt;

&lt;p&gt;The &lt;span class=&quot;badge&quot;&gt;perform&lt;/span&gt; method is the entry point for the job. 
This method will be called asynchronously when the job is executed, and it can 
receive any number of arguments. Inside this method, we can implement the logic 
for the job, which can include database operations, HTTP requests, or any other 
kind of processing.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;b-enqueuing-a-job&quot;&gt;b). Enqueuing a job&lt;/h3&gt;

&lt;p&gt;To enqueue a job, we can create a new instance of the job class and call the 
&lt;span class=&quot;badge&quot;&gt;perform_later&lt;/span&gt; method on it. For example, to enqueue a 
&lt;span class=&quot;badge&quot;&gt;NotificationJob&lt;/span&gt; with the argument “Hello, world!”, we 
can write:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;NotificationJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;perform_later&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will add a new job to the queue, which will be executed asynchronously by 
ActiveJob.&lt;/p&gt;

&lt;p&gt;By default, ActiveJob uses the Async queuing backend, which performs background 
processing in the same process as the Rails application. This can be useful for 
development or testing, but it is not recommended for production environments, 
where a separate queuing backend should be used.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;c-configuring-the-queuing-backend&quot;&gt;c). Configuring the queuing backend&lt;/h3&gt;

&lt;p&gt;ActiveJob supports several queuing backends, each with its own advantages and 
disadvantages. The most common queuing backends are Delayed Job, Resque, and 
Sidekiq, which provide more robust and scalable background processing than the 
default Async backend. In this section, we will explore how to configure 
ActiveJob to use these queuing backends.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;i-delayed-job&quot;&gt;i). Delayed Job&lt;/h3&gt;

&lt;p&gt;Delayed Job is a popular queuing backend for Rails applications. It provides a 
simple way to perform background processing using a separate process or thread 
pool. To use Delayed Job with ActiveJob, we need to add the &lt;span class=&quot;badge&quot;&gt;
delayed_job&lt;/span&gt; gem to our Gemfile and run &lt;span class=&quot;badge&quot;&gt;bundle install
&lt;/span&gt;. Then, we can configure ActiveJob to use the Delayed Job backend by 
setting the &lt;span class=&quot;badge&quot;&gt;queue_adapter&lt;/span&gt; option in our application 
configuration:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# config/application.rb&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;active_job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;queue_adapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:delayed_job&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
With this configuration, ActiveJob will use the Delayed Job backend to enqueue 
and execute jobs.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;ii-resque&quot;&gt;ii). Resque&lt;/h3&gt;

&lt;p&gt;Resque is another queuing backend for Rails applications, based on Redis. It 
provides a scalable and fault-tolerant way to perform background processing, with 
support for job priorities, job dependencies, and job retries. To use Resque with 
ActiveJob, we need to add the &lt;span class=&quot;badge&quot;&gt;resque&lt;/span&gt; and 
&lt;span class=&quot;badge&quot;&gt;resque-scheduler&lt;/span&gt; gems to our Gemfile and run 
&lt;span class=&quot;badge&quot;&gt;bundle install&lt;/span&gt;. Then, we can configure ActiveJob to 
use the Resque backend by setting the &lt;span class=&quot;badge&quot;&gt;queue_adapter&lt;/span&gt; 
option in our application configuration:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# config/application.rb&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;active_job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;queue_adapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:resque&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
With this configuration, ActiveJob will use the Resque backend to enqueue and 
execute jobs.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;iii-sidekiq&quot;&gt;iii). Sidekiq&lt;/h3&gt;

&lt;p&gt;Sidekiq is a powerful and popular queuing backend for Rails applications, based 
on Redis and multi-threading. It provides a fast and efficient way to perform 
background processing, with support for job retries, job batching, and job 
scheduling. To use Sidekiq with ActiveJob, we need to add the &lt;span class=&quot;badge&quot;&gt;
sidekiq&lt;/span&gt; gem to our Gemfile and run &lt;span class=&quot;badge&quot;&gt;bundle install&lt;/span&gt;. 
Then, we can configure ActiveJob to use the Sidekiq backend by setting the 
&lt;span class=&quot;badge&quot;&gt;queue_adapter&lt;/span&gt; option in our application configuration:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# config/application.rb&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;active_job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;queue_adapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:sidekiq&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
With this configuration, ActiveJob will use the Sidekiq backend to enqueue and 
execute jobs.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;ActiveJob is a powerful and flexible way to perform background processing in 
Rails applications. It provides a unified interface for working with different 
queuing backends, allowing developers to switch between them with minimal effort. 
By using ActiveJob, we can offload long-running or resource-intensive tasks from 
the main request-response cycle, improving the performance and scalability of our 
applications. With the support for retries, failures, and monitoring, ActiveJob 
makes it easy to build robust and fault-tolerant background processing workflows.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Building a Scalable and Fault-tolerant Rails Application Architecture</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/building-a-scalable-and-fault-tolerant-rails-application-architecture.markdown" rel="alternate" type="text/html" title="Building a Scalable and Fault-tolerant Rails Application Architecture" /><published>2023-04-15T16:00:00+03:00</published><updated>2023-04-15T16:00:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/building-a-scalable%20and-fault-tolerant-rails-application-architecture.markdown</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/building-a-scalable-and-fault-tolerant-rails-application-architecture.markdown">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Rails is a popular web application framework that has been widely adopted by 
developers for building scalable and fault-tolerant web applications. Building a 
scalable and fault-tolerant Rails application architecture requires careful 
planning and implementation to ensure that the application can handle increased 
traffic and maintain uptime even in the face of unexpected failures.&lt;/p&gt;

&lt;p&gt;In this article, we’ll explore some key considerations for building a scalable 
and fault-tolerant Rails application architecture.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1--use-a-load-balancer&quot;&gt;1 . Use a Load Balancer&lt;/h3&gt;

&lt;p&gt;One of the first things you should consider when building a scalable and fault-tolerant 
Rails application architecture is the use of a load balancer. A load balancer 
helps distribute incoming traffic evenly across multiple servers, ensuring that 
no single server becomes overloaded.&lt;/p&gt;

&lt;p&gt;There are several load balancers available for Rails applications, including 
software-based solutions like HAProxy and NGINX, and cloud-based solutions like 
AWS Elastic Load Balancer (ELB) and Google Cloud Load Balancing. Regardless of 
which load balancer you choose, it’s important to configure it correctly to ensure 
that it can handle increased traffic and failover to backup servers in the event 
of a failure.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2--use-multiple-web-servers&quot;&gt;2 . Use Multiple Web Servers&lt;/h3&gt;

&lt;p&gt;Another key component of a scalable and fault-tolerant Rails application architecture 
is the use of multiple web servers. By deploying your Rails application across 
multiple servers, you can ensure that your application can handle increased traffic 
and maintain uptime even in the face of unexpected failures.&lt;/p&gt;

&lt;p&gt;There are several ways to deploy a Rails application across multiple web servers, 
including using a cloud-based infrastructure like AWS or Google Cloud Platform, 
or using a container orchestration platform like Kubernetes or Docker Swarm.&lt;/p&gt;

&lt;p&gt;Regardless of which deployment strategy you choose, it’s important to configure 
your servers correctly to ensure that they can handle increased traffic and 
failover to backup servers in the event of a failure.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3--use-a-database-replication-strategy&quot;&gt;3 . Use a Database Replication Strategy&lt;/h3&gt;

&lt;p&gt;A database replication strategy is another key component of a scalable and 
fault-tolerant Rails application architecture. By replicating your database across 
multiple servers, you can ensure that your application can handle increased traffic 
and maintain uptime even in the face of unexpected failures.&lt;/p&gt;

&lt;p&gt;There are several database replication strategies available for Rails applications, 
including master-slave replication and multi-master replication. Regardless of 
which replication strategy you choose, it’s important to configure your database 
servers correctly to ensure that they can handle increased traffic and failover 
to backup servers in the event of a failure.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4--use-caching&quot;&gt;4 . Use Caching&lt;/h3&gt;

&lt;p&gt;Caching is another important component of a scalable and fault-tolerant Rails 
application architecture. By caching frequently accessed data, you can reduce the 
load on your servers and improve application performance.&lt;/p&gt;

&lt;p&gt;There are several caching strategies available for Rails applications, including 
in-memory caching, file-based caching, and distributed caching using tools like 
Redis or Memcached. Regardless of which caching strategy you choose, it’s important 
to configure your caching layer correctly to ensure that it can handle increased 
traffic and failover to backup servers in the event of a failure.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;5--choose-the-right-infrastructure-provider&quot;&gt;5 . Choose The Right Infrastructure Provider&lt;/h3&gt;

&lt;p&gt;Cloud providers like AWS, Google Cloud Platform, and Microsoft Azure offer a wide 
range of tools and services that can help you build a highly available and scalable 
architecture. These cloud providers offer tools like load balancers, auto-scaling 
groups, and managed databases that can help you quickly and easily scale your 
application as needed.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;6--use-a-microservices-architecture&quot;&gt;6 . Use a Microservices Architecture&lt;/h3&gt;

&lt;p&gt;With a microservices architecture, your application is broken down into smaller, 
independent services, each with its own database and API. This allows you to scale 
individual services as needed, and also makes it easier to troubleshoot and debug 
issues when they arise.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;7--monitor-and-analyze-application-performance&quot;&gt;7 . Monitor and Analyze Application Performance&lt;/h3&gt;

&lt;p&gt;Finally, it’s important to monitor and analyze the performance of your Rails 
application on an ongoing basis. By tracking key performance metrics like response 
time, throughput, and error rate, you can identify potential performance bottlenecks 
and take action to address them before they impact application availability.&lt;/p&gt;

&lt;p&gt;There are several monitoring and analysis tools available for Rails applications, 
including New Relic, AppSignal, and Scout. Regardless of which tool you choose, 
it’s important to configure it correctly and regularly review performance metrics 
to ensure that your application is running smoothly.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In conclusion, building a scalable and fault-tolerant Rails application architecture 
requires careful planning, implementation, and ongoing monitoring. By using a load 
balancer, deploying multiple web servers, implementing a database replication 
strategy, using caching, and monitoring application performance, you can ensure 
that your application can handle increased traffic and maintain uptime even in 
the face of unexpected failures. Additionally, choosing the right infrastructure 
provider and using a microservices architecture can help you quickly and easily 
scale your application as needed.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Optimizing Database Performance in Rails: Tips and Tricks</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/optimizing-database-performance-in-rails" rel="alternate" type="text/html" title="Optimizing Database Performance in Rails: Tips and Tricks" /><published>2023-04-08T10:00:00+03:00</published><updated>2023-04-08T10:00:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/optimizing-database-performance-in-rails</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/optimizing-database-performance-in-rails">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;As your Rails application grows, database performance can become a bottleneck. 
Slow queries and inefficient database operations can negatively impact the user 
experience and make your application feel sluggish. In this article, we will discuss 
tips and tricks for optimizing database performance in Rails.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-use-indexes&quot;&gt;1. Use indexes&lt;/h3&gt;

&lt;p&gt;Indexes can significantly improve query performance. Ensure that the columns 
commonly used in WHERE clauses, JOINs, and ORDER BY clauses are indexed. 
To create an index, you can use the Rails migration generator:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;add_index&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:email&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will create an index on the email column of the users table.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-avoid-n1-queries&quot;&gt;2. Avoid N+1 queries&lt;/h3&gt;

&lt;p&gt;N+1 queries occur when a query is executed for each record in a collection. 
This can lead to a large number of queries and significantly slow down your application. 
Use eager loading to preload associated records and avoid this issue. 
You can use the includes method to eager load associations:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;vi&quot;&gt;@users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;includes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:posts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will preload the posts association for all User records in a single query.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-use-caching&quot;&gt;3. Use caching&lt;/h3&gt;

&lt;p&gt;Caching can improve performance by reducing the number of queries made to the database. 
Consider using Rails caching mechanisms like fragment caching, low-level caching, 
and page caching. You can use the cache method to cache fragments of views:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- user profile content --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will cache the user profile content for the specified user.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-use-database-specific-features&quot;&gt;4. Use database-specific features&lt;/h3&gt;

&lt;p&gt;Different databases have specific features that can be used to optimize performance. 
For example, PostgreSQL has full-text search capabilities, while MySQL has spatial 
data indexing. Use these features to your advantage when building your application.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-use-database-connection-pooling&quot;&gt;5. Use database connection pooling&lt;/h3&gt;

&lt;p&gt;Connection pooling can improve database performance by reusing database connections 
rather than creating new ones for each request. You can use the connection_pool 
method to manage database connections:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;ActiveRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;connection_pool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with_connection&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# database operation&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will ensure that the database connection is reused for subsequent database operations.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-optimize-queries&quot;&gt;6. Optimize queries&lt;/h3&gt;

&lt;p&gt;Write efficient queries that use appropriate SELECT statements, WHERE clauses, and JOINs. 
Avoid using complex ORMs for complex queries, as they can be slow and inefficient. 
Consider writing custom SQL queries instead.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;7-use-pagination&quot;&gt;7. Use pagination&lt;/h3&gt;

&lt;p&gt;Limit the number of records returned by a query by using pagination. 
This can significantly improve performance for large datasets. You can use the 
&lt;span class=&quot;badge&quot;&gt;will_paginate&lt;/span&gt; gem to implement pagination:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;vi&quot;&gt;@users&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;paginate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;page: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;per_page: &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will limit the number of User records returned to 10 per page.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;8-monitor-database-performance&quot;&gt;8. Monitor database performance&lt;/h3&gt;

&lt;p&gt;Use tools like New Relic or Scout to monitor database performance and identify 
slow queries or other performance bottlenecks. This will help you identify areas 
of your application that need optimization.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;9-use-background-processing&quot;&gt;9. Use background processing&lt;/h3&gt;

&lt;p&gt;Move expensive database operations, like sending emails or generating reports, 
to background jobs using tools like Sidekiq or Resque. This will improve the overall 
performance of your application by offloading CPU-intensive tasks to a separate process.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In conclusion, optimizing database performance is an important aspect of building 
a high-performance Rails application. By following these tips and tricks, you can 
improve the performance of your application and provide a better user experience for your users.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Common Vulnerabilities and Best Practices for Rails Security</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/common-vulnerabilities-and-best-practices-for-rails-security" rel="alternate" type="text/html" title="Common Vulnerabilities and Best Practices for Rails Security" /><published>2023-04-01T18:30:00+03:00</published><updated>2023-04-01T18:30:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/common-vulnerabilities-and-best-practices-for-rails-security</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202304/common-vulnerabilities-and-best-practices-for-rails-security">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Ruby on Rails is a powerful and popular web development framework that has gained 
a reputation for being secure. However, like any web application, a Rails app is 
vulnerable to security attacks if it is not properly secured. Rails security is 
a vast topic, but there are some common vulnerabilities and best practices that 
you should be aware of to make your application secure.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;common-rails-security-vulnerabilities&quot;&gt;Common Rails Security Vulnerabilities&lt;/h3&gt;

&lt;p&gt;1 . Cross-Site Scripting (XSS) Attacks: It is a type of security vulnerability 
that allows an attacker to inject malicious code into a web page viewed by other users. 
Rails has built-in protections against XSS attacks, but it is essential to 
sanitize user input properly to prevent these attacks.&lt;/p&gt;

&lt;p&gt;For example, consider a form where users can input their name. If the form does 
not validate the input and sanitize it properly, an attacker can inject a malicious 
script as their name, which can then execute on the user’s browser when the page loads. 
Rails provides built-in sanitization methods like sanitize and strip_tags to prevent XSS attacks.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
2 . SQL Injection Attacks: This type of attack occurs when an attacker inserts 
malicious SQL code into a query. Rails provides built-in protection against SQL 
injection attacks through Active Record. Still, it’s necessary to ensure that 
user input is properly validated and sanitized.&lt;/p&gt;

&lt;p&gt;For example, consider a form where users can search for products by entering keywords. 
If the search form does not validate and sanitize the input properly, an attacker 
can inject malicious SQL code into the query, which can then execute on the server 
and potentially allow the attacker to access sensitive data. Rails provides 
built-in protection against SQL injection attacks through parameterized queries.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
3 . Cross-Site Request Forgery (CSRF) Attacks: In this type of attack, the attacker 
tricks the user into performing an action without their consent. Rails provides 
built-in protection against CSRF attacks through CSRF tokens.&lt;/p&gt;

&lt;p&gt;For example, consider a form where users can update their account information. 
If the form does not include a CSRF token, an attacker can trick the user into 
submitting the form by luring them to a malicious website that sends the form 
data to the server. Rails provides built-in protection against CSRF attacks by 
generating a unique CSRF token for each form and requiring it to be included in the form data.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;best-practices-for-rails-security&quot;&gt;Best Practices for Rails Security:&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Input validation and sanitization: You should always validate and sanitize user 
input to prevent security vulnerabilities like XSS and SQL injection attacks. 
Rails provides built-in sanitization methods like sanitize and strip_tags to 
prevent XSS attacks, and parameterized queries to prevent SQL injection attacks.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use strong authentication and authorization: Implementing strong authentication 
and authorization practices can help protect your Rails app against unauthorized access. 
Use strong passwords and hash them properly to prevent password-related attacks. 
You can use libraries like Devise or Authlogic to implement authentication and authorization in your Rails app.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use HTTPS: Always use HTTPS to ensure that data transmitted between the server 
and the client is encrypted. Use libraries like OpenSSL to configure HTTPS in your Rails app.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keep your Rails app up-to-date: Regularly update your Rails app and its 
dependencies to ensure that any security vulnerabilities are patched. You can use 
libraries like Bundler and Dependabot to manage your app’s dependencies.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use third-party libraries judiciously: Always check the reputation of third-party 
libraries before using them in your Rails app. Use libraries that have a good 
track record, are well-maintained, and have been reviewed by the community.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In conclusion, Rails security is a complex topic that requires constant vigilance. 
By following best practices and regularly updating your app, you can make your 
Rails application secure against common security vulnerabilities. Always validate&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Caching in Rails</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/caching-in-rails" rel="alternate" type="text/html" title="Caching in Rails" /><published>2023-03-26T11:40:00+03:00</published><updated>2023-03-26T11:40:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/caching-in-rails</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/caching-in-rails">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Rails provides several types of caching to help improve the performance of your 
application. The three most commonly used types of caching are fragment caching, 
action caching, and HTTP caching. Let’s take a closer look at each type of caching 
and when to use it.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;page-caching&quot;&gt;Page Caching&lt;/h3&gt;

&lt;p&gt;Page caching is the simplest form of caching available in Rails 7. It involves 
saving the entire HTML response of a page to a file and serving the same file for 
subsequent requests. This type of caching is useful for pages that don’t have any 
dynamic content, such as homepages, about us pages, or other static pages.&lt;/p&gt;

&lt;p&gt;To enable page caching, you can use the caches_page method in your controller, like this:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HomeController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ApplicationController&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;caches_page&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:index&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# code to render the page&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
In this example, the &lt;span class=&quot;badge&quot;&gt;caches_page&lt;/span&gt; method caches the 
HTML response for the &lt;span class=&quot;badge&quot;&gt;index&lt;/span&gt; action of the 
&lt;span class=&quot;badge&quot;&gt;HomeController&lt;/span&gt; class. Whenever a user requests 
the &lt;span class=&quot;badge&quot;&gt;index&lt;/span&gt; page, Rails will serve the cached HTML 
response instead of rendering the page again.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;fragment-caching&quot;&gt;Fragment Caching:&lt;/h3&gt;

&lt;p&gt;Fragment caching is used to cache parts of a view that are expensive to generate. 
For example, if you have a page that includes a list of articles and each article 
has many comments, rendering the page may take a long time if you have to load 
all the comments for each article on every request. To speed up the rendering process, 
you can use fragment caching to cache the comments for each article separately.&lt;/p&gt;

&lt;p&gt;To use fragment caching, wrap the expensive code in a cache block like this:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;article.comments&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;render&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;article.comments&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will cache the output of the expensive code and use it on subsequent requests, 
avoiding the need to regenerate it each time. In this example, the comments for 
each article are cached separately, so if a new comment is added to one of the articles, 
only the cached fragment for that article will be invalidated.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;action-caching&quot;&gt;Action Caching:&lt;/h3&gt;

&lt;p&gt;Action Caching works like Page Caching except the incoming web request hits the 
Rails stack so that &lt;span class=&quot;badge&quot;&gt;before&lt;/span&gt; filters can be run on it 
before the cache is served.&lt;/p&gt;

&lt;p&gt;This ensures that any actions needing to take place before the cached copy is hit 
can be performed. Therefore increasing performance while taking into account the 
functionality required to access parts of your application.&lt;/p&gt;

&lt;p&gt;Suppose you have a before filter that checks whether the user is authorized to 
view the article. If the user is authorized, the cached copy of the article is 
served, and if the user is not authorized, the before filter redirects the user 
to the login page.&lt;/p&gt;

&lt;p&gt;Here’s an example of how you can use Action Caching in your Rails 7 application:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArticlesController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ApplicationController&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;before_action&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:authenticate_user!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;except: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;show&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@article&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Article&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# ... other code to render the article page ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cache_action&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;admin?&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;kp&quot;&gt;private&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cache_action&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Cache-Control&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;public, max-age=300&apos;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;expires_in&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;minutes&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
In this example, we have a &lt;span class=&quot;badge&quot;&gt;before_action :authenticate_user!&lt;/span&gt;, 
which ensures that only authenticated users can view the article. In the show 
action, we use cache_action to cache the output of the action for 5 minutes, 
but only if the current user is not an admin. This ensures that non-admin users 
get the cached copy of the article, and the before_filter 
&lt;span class=&quot;badge&quot;&gt;:authenticate_user!&lt;/span&gt; is executed before serving the cached copy.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;http-caching&quot;&gt;HTTP Caching:&lt;/h3&gt;

&lt;p&gt;HTTP caching is used to cache responses from the server and avoid unnecessary 
network requests. For example, if you have a page that displays a list of products, 
you can use HTTP caching to allow the client to cache the response and avoid 
downloading unnecessary data.&lt;/p&gt;

&lt;p&gt;To use HTTP caching, add the following code to your controller action:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@products&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fresh_when&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;last_modified: &lt;/span&gt;&lt;span class=&quot;vi&quot;&gt;@products&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;maximum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:updated_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;public: &lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will set the &lt;span class=&quot;badge&quot;&gt;Last-Modified&lt;/span&gt; and 
&lt;span class=&quot;badge&quot;&gt;ETag&lt;/span&gt; headers on the response, allowing the 
client to make conditional requests and avoid downloading unnecessary data. 
In this example, the response will be cached based on the 
&lt;span class=&quot;badge&quot;&gt;last_modified&lt;/span&gt; timestamp of the products, so if a new 
product is added or an existing product is updated, the cached response will be 
invalidated and regenerated.&lt;/p&gt;

&lt;p&gt;In addition to these types of caching, Rails also provides other caching mechanisms 
like low-level caching and Russian doll caching. Low-level caching is used to cache 
arbitrary objects, such as database queries or API responses. Russian doll caching 
is used to cache nested fragments of a view, which can be useful when you have 
complex views with many nested elements.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;When using caching in your Rails application, it’s important to consider the 
trade-offs between performance and complexity. Caching can significantly improve 
the performance of your application, but it can also introduce some complexity 
and potential issues, such as cache invalidation and cache consistency. 
Be sure to test your application thoroughly with caching enabled and monitor its 
performance to ensure that it’s working as expected.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Nginx: Features, Benefits, and Use Cases</title><link href="http://0.0.0.0:4000/category/more-topics/cloud-services/servers/202303/nginx-features-benefits-and-use-uases" rel="alternate" type="text/html" title="Nginx: Features, Benefits, and Use Cases" /><published>2023-03-19T12:00:00+03:00</published><updated>2023-03-19T12:00:00+03:00</updated><id>http://0.0.0.0:4000/category/more-topics/cloud-services/servers/202303/nginx-features-benefits-and-use-uases</id><content type="html" xml:base="http://0.0.0.0:4000/category/more-topics/cloud-services/servers/202303/nginx-features-benefits-and-use-uases">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Nginx is a high-performance, open-source web server and reverse proxy software 
that has gained widespread popularity in recent years. It is known for its speed, 
scalability, and flexibility, and is used by some of the world’s largest websites 
and applications.&lt;/p&gt;

&lt;p&gt;In this guide, we’ll take a closer look at what Nginx is, what features it offers, 
and some of the benefits and use cases for using Nginx in your web applications.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;definition&quot;&gt;Definition&lt;/h3&gt;

&lt;p&gt;Nginx (pronounced “engine-x”) is a lightweight, open-source HTTP server software 
that was first released in 2004. It was designed to be a high-performance alternative 
to the Apache HTTP Server, which was the dominant web server software at the time.&lt;/p&gt;

&lt;p&gt;Nginx is often used as a reverse proxy server or load balancer, which means it 
sits in front of web servers and handles incoming client requests, forwarding 
them to the appropriate backend server to generate a response. It is also commonly 
used to serve static content, such as HTML, CSS, JavaScript, and images, as well 
as dynamic content generated by applications running on a backend server.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;features-of-nginx&quot;&gt;Features of Nginx&lt;/h3&gt;

&lt;p&gt;Nginx offers a wide range of features that make it a popular choice for web 
developers and administrators. Here are some of the key features of Nginx:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;High Performance: Nginx is known for its high performance and low resource usage. 
It can handle large amounts of traffic and is optimized for serving static content 
and handling multiple concurrent connections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scalability: Nginx can be used as a load balancer to distribute incoming traffic 
among multiple servers, helping to improve scalability and availability of web 
applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reverse Proxy: Nginx can act as a reverse proxy to protect backend servers from 
direct exposure to the internet, as well as provide additional security features 
such as SSL termination, authentication, and access control.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Caching: Nginx can serve as a cache for static content, helping to reduce the 
load on backend servers and improve response times for clients. It can also cache 
dynamic content with appropriate headers to improve application performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSL/TLS termination: Nginx can terminate SSL/TLS connections and pass unencrypted 
traffic to the backend server, reducing the load on the server and allowing for 
more efficient handling of SSL/TLS connections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Content filtering: Nginx can be used to filter and block specific types of 
traffic based on content or other criteria, providing an additional layer of 
security for web applications.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;benefits-of-using-nginx&quot;&gt;Benefits of using Nginx&lt;/h3&gt;

&lt;p&gt;Using Nginx as a web server or reverse proxy server can provide several benefits 
for web developers and administrators. Here are some of the key benefits of using Nginx:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Improved Performance: Nginx is optimized for serving static content and handling 
multiple concurrent connections, helping to improve the performance of web applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Enhanced Security: Nginx can act as a reverse proxy to protect backend servers 
from direct exposure to the internet, as well as provide additional security 
features such as SSL termination, authentication, and access control.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scalability: Nginx can be used as a load balancer to distribute incoming 
traffic among multiple servers, helping to improve scalability and availability 
of web applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Flexible Configuration: Nginx offers a flexible and powerful configuration 
language that allows administrators to customize the behavior of the server to 
meet their specific needs.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Open Source: Nginx is an open-source software, which means that it is freely 
available for download and can be modified and distributed under the terms of the license.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;use-cases-for-nginx&quot;&gt;Use Cases for Nginx&lt;/h3&gt;

&lt;p&gt;Nginx can be used in a wide range of applications and use cases, including but not limited to:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Serving Static Content: Nginx can serve static content such as HTML, CSS, 
JavaScript, and images, providing a high-performance and efficient way to deliver web content.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Load Balancing: Nginx can be used as a load balancer to distribute incoming 
traffic among multiple servers, helping to improve the availability and scalability 
of web applications.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reverse Proxy: Nginx can act as a reverse proxy to protect backend servers 
from direct exposure to the internet, as well as provide additional security 
features such as SSL termination, authentication, and access control.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Caching: Nginx can serve as a cache for static content, helping to reduce the 
load on backend servers and improve response times for clients. It can also cache 
dynamic content with appropriate headers to improve application performance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSL/TLS Termination: Nginx can terminate SSL/TLS connections and pass unencrypted 
traffic to the backend server, reducing the load on the server and allowing for 
more efficient handling of SSL/TLS connections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Content Filtering: Nginx can be used to filter and block specific types of 
traffic based on content or other criteria, providing an additional layer of 
security for web applications.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Nginx is a high-performance, flexible, and powerful web server and reverse proxy 
software that has become increasingly popular in recent years. Its ability to 
handle large amounts of traffic, serve static content efficiently, act as a load 
balancer, and provide additional security features make it a popular choice for 
web developers and administrators.&lt;/p&gt;

&lt;p&gt;In this guide, we’ve explored the key features and benefits of Nginx, as well as 
some common use cases for using Nginx in web applications. Whether you’re serving 
static content, distributing traffic among multiple servers, or protecting backend 
servers from direct exposure to the internet, Nginx is a versatile tool that can 
help you improve the performance, scalability, and security of your web applications.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="more-topics" /><summary type="html">Introduction</summary></entry><entry><title type="html">Rails Migrations Basics</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/rails-migrations-basics" rel="alternate" type="text/html" title="Rails Migrations Basics" /><published>2023-03-12T09:35:00+03:00</published><updated>2023-03-12T09:35:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/rails-migrations-basics</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/concepts/202303/rails-migrations-basics">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Rails Migrations are a powerful tool that allows developers to manage database 
changes and schema updates in a version-controlled and consistent way. Migrations 
help developers to easily modify the structure of their application’s database, 
and they are a key component of the Ruby on Rails framework.&lt;/p&gt;

&lt;p&gt;In this section, we’ll cover the basics of how to create, modify, and manage 
migrations in a Rails application.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;creating-a-migration&quot;&gt;Creating a Migration&lt;/h3&gt;

&lt;p&gt;To create a new migration in a Rails application, you can use the 
&lt;span class=&quot;badge&quot;&gt;rails generate&lt;/span&gt; command followed by the migration name 
and the list of attributes that you want to add to the database table. For example, 
to create a migration that adds a new column to the users table, you can run the 
following command:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails generate migration add_email_to_users email:string&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will create a new migration file in the &lt;span class=&quot;badge&quot;&gt;db/migrate&lt;/span&gt; 
directory with a name that looks something like 
&lt;span class=&quot;badge&quot;&gt;20210312132235_add_email_to_users.rb&lt;/span&gt;. The name of the 
migration file includes a timestamp to ensure that each migration is executed in 
the correct order.&lt;/p&gt;

&lt;p&gt;The migration file will contain two methods: &lt;span class=&quot;badge&quot;&gt;up&lt;/span&gt; and 
&lt;span class=&quot;badge&quot;&gt;down&lt;/span&gt;. The &lt;span class=&quot;badge&quot;&gt;up&lt;/span&gt; method is used 
to define the changes that need to be made to the database, and the 
&lt;span class=&quot;badge&quot;&gt;down&lt;/span&gt; method is used to define how to revert those changes.&lt;/p&gt;

&lt;p&gt;Here’s an example of what the up method might look like for the 
&lt;span class=&quot;badge&quot;&gt;add_email_to_users&lt;/span&gt; migration:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;up&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;add_column&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will add a new column named email to the users table with a data type 
of string.&lt;/p&gt;

&lt;p&gt;The &lt;span class=&quot;badge&quot;&gt;down&lt;/span&gt; method is used to undo the changes made by 
the &lt;span class=&quot;badge&quot;&gt;up&lt;/span&gt; method. Here’s an example of what the 
&lt;span class=&quot;badge&quot;&gt;down&lt;/span&gt; method might look like for the 
&lt;span class=&quot;badge&quot;&gt;add_email_to_users&lt;/span&gt; migration:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;down&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;remove_column&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:email&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will remove the email column from the users table.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;running-migrations&quot;&gt;Running Migrations&lt;/h3&gt;

&lt;p&gt;Once you’ve created a migration, you can run it by running the following command:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails db:migrate&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will execute all the pending migrations in your application. Rails keeps 
track of which migrations have already been run, so running 
&lt;span class=&quot;badge&quot;&gt;rails db:migrate&lt;/span&gt; multiple times will not apply the 
same migration more than once.&lt;/p&gt;

&lt;p&gt;You can also roll back a migration by running the following command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails db:rollback&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will undo the last migration that was applied. You can roll back multiple 
migrations by specifying the number of migrations to roll back:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails db:rollback &lt;span class=&quot;nv&quot;&gt;STEP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will roll back the last two migrations that were applied.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;modifying-a-migration&quot;&gt;Modifying a Migration&lt;/h3&gt;

&lt;p&gt;If you need to modify an existing migration, you can edit the migration file directly. 
However, you should be aware that once a migration has been run, it should not 
be modified unless absolutely necessary. Modifying a migration that has already 
been applied can cause issues with the consistency of your database schema.&lt;/p&gt;

&lt;p&gt;If you need to make a change to a migration that has already been run, you 
should create a new migration that modifies the existing schema. For example, 
if you need to rename a column that was added in a previous migration, you could 
create a new migration that renames the column:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-terminal&quot; data-lang=&quot;terminal&quot;&gt;&lt;span class=&quot;gp&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;rails generate migration rename_email_column_in_users&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This will create a new migration file that you can use to rename the column. 
Here’s an example of what the up method might look like:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;up&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rename_column&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:email&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:new_email&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will rename the email column to new_email.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;adding-indexes&quot;&gt;Adding Indexes&lt;/h3&gt;

&lt;p&gt;Adding indexes to your database tables can help to improve query performance. 
You can create an index on a column in a table using a migration. Here’s an 
example of how to create an index on the email column in the users table:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;change&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;add_index&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:email&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will create an index on the email column in the users table. Rails will 
automatically generate a name for the index based on the table and column names.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;dropping-tables&quot;&gt;Dropping Tables&lt;/h3&gt;

&lt;p&gt;If you need to remove a table from your database, you can do so using a migration. 
Here’s an example of how to remove the users table:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;change&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;drop_table&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:users&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This code will remove the users table from your database.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Migrations are a powerful tool that allow you to manage database changes and 
schema updates in a version-controlled and consistent way. In this tutorial, 
we covered the basics of how to create, modify, and manage migrations in a 
Rails application.&lt;/p&gt;

&lt;p&gt;Remember that once a migration has been applied, it should not be modified unless 
absolutely necessary. If you need to make a change to a migration that has already 
been applied, create a new migration that modifies the existing schema.&lt;/p&gt;

&lt;p&gt;With Rails Migrations, you can easily modify the structure of your application’s 
database and keep your schema in sync with your application’s code.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">Debugging Rails applications with Pry or Byebug</title><link href="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/tutorials/202303/debugging-rails-applications-with-pry-or-byebug" rel="alternate" type="text/html" title="Debugging Rails applications with Pry or Byebug" /><published>2023-03-05T13:15:00+03:00</published><updated>2023-03-05T13:15:00+03:00</updated><id>http://0.0.0.0:4000/category/frameworks/ruby-on-rails/tutorials/202303/debugging-rails-applications-with-pry-or-byebug</id><content type="html" xml:base="http://0.0.0.0:4000/category/frameworks/ruby-on-rails/tutorials/202303/debugging-rails-applications-with-pry-or-byebug">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Debugging is an essential part of developing a Ruby on Rails application. 
It involves finding and fixing errors or bugs in the code. There are different 
techniques and tools for debugging Rails applications, but in this tutorial, 
we’ll focus on two popular Ruby debugging tools: Pry and Byebug.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;what-is-pry&quot;&gt;What is Pry?&lt;/h3&gt;

&lt;p&gt;Pry is a powerful Ruby REPL (Read-Eval-Print Loop) that allows us to interact 
with our code in real-time. We can use Pry to debug our Ruby code, inspect objects, 
and test code snippets. Pry provides several advanced features, including syntax 
highlighting, code introspection, and method discovery.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;what-is-byebug&quot;&gt;What is Byebug?&lt;/h3&gt;

&lt;p&gt;Byebug is a fast and efficient Ruby debugger that allows us to debug our code 
interactively. Byebug provides a range of powerful features, including step-by-step 
execution, breakpoint management, and stack trace inspection.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;

&lt;p&gt;Before we can start using Pry or Byebug, we need to install them. To install 
them, add the following lines to your Gemfile:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;pry-rails&apos;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gem&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;byebug&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;using-pry&quot;&gt;Using Pry&lt;/h3&gt;

&lt;p&gt;Once Pry is installed, we can start using it to debug our Rails application. 
To use Pry, we need to add the following line to the code where we want to start debugging:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;nb&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pry&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
This line will pause the execution of the code and open a Pry console, where we 
can inspect variables, call methods, and execute arbitrary Ruby code.&lt;/p&gt;

&lt;p&gt;For example, let’s say we have a controller action that’s not behaving as expected:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@posts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@categories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
To debug this action with Pry, we can add the &lt;span class=&quot;badge&quot;&gt;binding.pry&lt;/span&gt; 
line after the first line:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;index&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;pry&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@posts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
  &lt;span class=&quot;vi&quot;&gt;@categories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Category&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;all&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
When we load the page that triggers this action, the execution will pause at the 
binding.pry line, and we’ll be dropped into a Pry console where we can inspect 
the &lt;span class=&quot;badge&quot;&gt;@posts&lt;/span&gt; and &lt;span class=&quot;badge&quot;&gt;@categories&lt;/span&gt; 
variables, call methods on them, and execute arbitrary 
Ruby code to help us debug the issue.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;pry-commands&quot;&gt;Pry Commands&lt;/h3&gt;

&lt;p&gt;Pry provides several commands that we can use to interact with our code during debugging. Some of the most commonly used commands are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ls: List the methods available on an object.&lt;/li&gt;
  &lt;li&gt;cd: Change the current context to a different object.&lt;/li&gt;
  &lt;li&gt;whereami: Show the current execution context.&lt;/li&gt;
  &lt;li&gt;exit: Exit the Pry console.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;using-byebug&quot;&gt;Using Byebug&lt;/h3&gt;

&lt;p&gt;Byebug works similarly to Pry, but instead of adding a 
&lt;span class=&quot;badge&quot;&gt;binding.pry&lt;/span&gt; line to the code, we add a byebug line:&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;def index
  byebug
  @posts = Post.all
  @categories = Category.all
end&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
When we load the page that triggers this action, the execution will pause at the 
byebug line, and we’ll be dropped into a Byebug console where we can inspect 
variables, call methods, and execute arbitrary Ruby code to help us debug the issue.&lt;/p&gt;

&lt;p&gt;Byebug also includes a number of commands that can help us navigate the code and 
inspect variables. Some of the most commonly used commands are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;step: Step into the next line of code.&lt;/li&gt;
  &lt;li&gt;next: Step over the next line of code.&lt;/li&gt;
  &lt;li&gt;finish: Continue executing until the current method returns.&lt;/li&gt;
  &lt;li&gt;continue: Continue executing until the next breakpoint or exception.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
Additionally, there are a few tips and best practices to keep in mind when 
debugging with Pry or Byebug:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Use breakpoints sparingly: Breakpoints can be a powerful tool, but using them 
too frequently can slow down your debugging process. Use them strategically to 
focus on the parts of the code that you suspect are causing the issue.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Understand the stack trace: When an error occurs, it can be helpful to examine 
the stack trace to see where the error originated. This can help you narrow down 
the source of the problem and guide your debugging efforts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use Pry or Byebug commands: Pry and Byebug both come with a set of useful commands 
that can help you navigate and inspect your code. Familiarize yourself with these 
commands to make debugging faster and more efficient.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Keep your code organized: Writing clean, organized code can make debugging easier 
by making it easier to follow the flow of your application. Use descriptive variable 
names and break your code up into smaller, more manageable pieces to make it 
easier to debug.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Debugging Rails applications can be a challenging and time-consuming task, but 
with the help of tools like Pry and Byebug, we can make the process easier and 
more efficient. By adding &lt;span class=&quot;badge&quot;&gt;binding.pry&lt;/span&gt; or 
&lt;span class=&quot;badge&quot;&gt;byebug&lt;/span&gt; lines to our code, we can pause the execution 
of the code and inspect variables, call methods, and execute arbitrary Ruby code 
to help us diagnose and fix issues.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="frameworks" /><summary type="html">Introduction</summary></entry><entry><title type="html">How ChatGPT can Improve Productivity for Web Developers</title><link href="http://0.0.0.0:4000/category/more-topics/machine-learning/articles/202302/how-chatgpt-can-improve-productivity-for-web-developers" rel="alternate" type="text/html" title="How ChatGPT can Improve Productivity for Web Developers" /><published>2023-02-19T09:30:00+03:00</published><updated>2023-02-19T09:30:00+03:00</updated><id>http://0.0.0.0:4000/category/more-topics/machine-learning/articles/202302/how-chatgpt-can-improve-productivity-for-web-developers</id><content type="html" xml:base="http://0.0.0.0:4000/category/more-topics/machine-learning/articles/202302/how-chatgpt-can-improve-productivity-for-web-developers">&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;As a web developer, staying productive and on top of your tasks is critical to 
the success of your projects and the satisfaction of your clients. With the ever-evolving 
landscape of web development, it’s essential to be able to work efficiently and 
effectively to keep up with the latest technologies and best practices. This is 
where ChatGPT can help.&lt;/p&gt;

&lt;p&gt;ChatGPT is a large language model developed by OpenAI that uses deep learning 
techniques to understand and generate human-like text. As a result, it can provide 
valuable assistance to web developers in a range of areas, from coding to project management.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1--code-completion&quot;&gt;1 . Code Completion&lt;/h3&gt;

&lt;p&gt;One of the key benefits of ChatGPT for web developers is its ability to generate 
code snippets. If you’re working on a project and need a specific piece of code, 
you can ask ChatGPT for suggestions and it will provide you with relevant examples. 
Additionally, if you have partially written code, ChatGPT can complete it for you, 
saving you time and effort.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2--documentation&quot;&gt;2 . Documentation&lt;/h3&gt;

&lt;p&gt;Another way ChatGPT can improve your productivity as a web developer is by helping 
you with documentation. Whether you need information on a specific programming 
language, framework, library, or technology, you can ask ChatGPT for details and 
it will provide you with accurate and up-to-date information. This can be especially 
helpful when you’re working on a project and need to quickly reference something.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3--troubleshooting&quot;&gt;3 . Troubleshooting&lt;/h3&gt;

&lt;p&gt;Web development can often be a challenging and complex process, and it’s not uncommon 
to encounter problems and errors along the way. If you’re stuck on a problem, 
you can use ChatGPT to help identify the root cause and provide solutions. 
Simply ask ChatGPT about the error message or problem you’re facing, and it will 
provide you with relevant information and suggestions for fixing the issue.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4--research&quot;&gt;4 . Research&lt;/h3&gt;
&lt;p&gt;As a web developer, it’s important to stay informed about the latest developments 
in your field. ChatGPT can assist with your research by answering questions related 
to the latest technologies, best practices, and other relevant topics. This can 
help you stay up-to-date and improve your overall knowledge, which in turn can 
improve your productivity and the quality of your work.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;5--project-management&quot;&gt;5 . Project Management&lt;/h3&gt;
&lt;p&gt;Finally, ChatGPT can also assist with project management. You can use it to help 
keep track of project tasks and deadlines, generate project reports, and provide 
project progress updates. This can help you stay organized and on top of your 
projects, and ensure that everything is running smoothly.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;In conclusion, ChatGPT is a powerful tool that can significantly improve your 
productivity as a web developer. Whether you need help with coding, documentation, 
troubleshooting, research, or project management, ChatGPT can provide you with the 
information and support you need to get the job done. Just remember, while ChatGPT 
is a valuable resource, it’s always important to verify the information it provides 
before using it in your work.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;Thanks for reading, see you in the next one!&lt;/em&gt;&lt;/p&gt;</content><author><name>Denis Kobare</name></author><category term="more-topics" /><summary type="html">Introduction</summary></entry></feed>